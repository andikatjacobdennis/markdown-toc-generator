1.	Introduction to C#
1.1.	What is C#?
1.2.	History and Evolution
1.3..NET Framework vs .NET Core vs .NET 5/6/7+
1.4.	Setting Up the Development Environment
1.5.	First Program: "Hello, World!"
1.6.	Compilation and Execution
1.7.	C# Compiler (Roslyn)
2.	C# Language Basics
2.1.	Syntax and Structure
2.2.	Keywords and Identifiers
2.3.	Data Types and Variables
2.4.	Constants and Literals
2.5.	Type Casting and Conversions
2.6.	Operators (Arithmetic, Logical, Bitwise, etc.)
2.7.	Expressions and Statements
2.8.	Nullable Value Types (Nullable<T>, ? syntax)
2.9.	String Manipulation (string, StringBuilder, ReadOnlySpan<char>)
2.10.	REGEX
3.	Control Flow and Decision Making
3.1.	if, else, else if
3.2.	switch-case
3.3.	Loops: for, while, do-while and foreach
3.4.	break, continue, goto
3.5.	Pattern Matching - – is, switch expressions, property patterns
4.	Object-Oriented Programming (OOP)
4.1.	Classes and Objects
4.2.	Fields and Properties
4.3.	Methods
4.4.	Constructors
4.4.1.	What is a Constructor?
4.4.2.	Default Constructor
4.4.3.	Parameterized Constructor
4.4.4.	Static Constructor
4.4.5.	Copy Constructor
4.4.6.	Private Constructor
4.4.7.	Constructor Overloading
4.4.8.	Chaining Constructors (this keyword)
4.5.	Access Modifiers
4.6.	Inheritance
4.6.1.	new vs override
4.6.2.	base Keyword Usage
4.7.	Polymorphism (Method Overloading/Overriding)
4.8.	Abstraction and Interfaces
4.9.	Encapsulation
4.10.	Static vs Instance Members
4.11.	Partial Classes
4.12.	Object Initializers & Collection Initializers
4.13.	Nameof Operator
4.14.	Null-Conditional & Null-Coalescing Operators (?., ??, ??=) 
4.15.	Structs vs Classes
5.	Advanced OOP Concepts
5.1.	Abstract Classes and Interfaces
5.2.	Sealed Classes
5.3.	Delegates
5.4.	Events
5.5.	Anonymous Methods and Lambda Expressions
5.6.	Extension Methods
5.7.	Indexers
5.8.	Generics (Generic Classes, Methods, Constraints)
5.9.	Reflection and Metadata
5.10.	Records – Immutability, with expressions, value-based equality.
5.11.	Source Generators (C# 9+) – Compile-time code generation.
6.	Exception Handling
6.1.	try, catch, finally
6.2.	Custom Exceptions
6.3.	Exception Filters
6.4.	Throw Expressions
7.	Collections and Data Structures
7.1.	Arrays
7.2.	List , Dictionary , Queue , Stack , HashSet
7.3.	SortedList, SortedDictionary
7.4.	LinkedList
7.5.	ReadOnlyCollection
7.6.	Span  and Memory
7.7.	Collection Interfaces
7.7.1.	IEnumerable/IEnumerator
7.7.2.	IQueryable
7.7.3.	ICollection
7.7.4.	IList
7.7.5.	IEqualityComparer
7.7.6.	IComparable
7.8.	Immutable Collections (ImmutableList, ImmutableDictionary) – Thread-safe collections.
7.9.	Concurrent Collections (ConcurrentBag, ConcurrentQueue) – Thread-safe alternatives.
8.	LINQ (Language Integrated Query)
8.1.	LINQ Basics and Syntax
8.2.	LINQ Types
8.2.1.	LINQ to Objects
8.2.2.	LINQ to SQL
8.2.3.	LINQ to XML
8.2.4.	LINQ to Entities
8.3.	Query Syntax vs Method Syntax
8.4.	Deferred vs Immediate Execution
8.5.	Custom LINQ Operators
9.	File and I/O Handling
9.1.	File, Directory, Path Classes
9.2.	StreamReader and StreamWriter
9.3.	BinaryReader and BinaryWriter
9.4.	FileStream and MemoryStream
9.5.	Working with JSON
9.6.	Working with XML
9.7.	Asynchronous File I/O (FileStream with async/await) – Performance considerations.
9.8.	Memory-Mapped Files – High-performance file access.
10.	Asynchronous Programming
10.1.	async and await
10.2.	Task and Task
10.3.	Threading and Thread Lifecycle
10.3.1.	Thread States
10.3.2.	Thread Pool
10.3.3.	Thread Synchronization
10.4.	Parallel Programming (TPL)
10.5.	BackgroundWorker
10.6.	Cancellation Tokens
10.7.	Synchronization Context
10.8.	ValueTask vs Task – Performance optimizations.
10.9.	Channels (System.Threading.Channels) – Producer/Consumer patterns.
10.10.	Async Streams (IAsyncEnumerable) – Streaming data asynchronously.
11.	ADO.NET and Database Access
11.1.	ADO.NET Architecture
11.2.	Connection and Command Objects
11.3.	DataReader vs DataSet
11.4.	Parameterized Queries
11.5.	Transactions
11.6.	Stored Procedures
12.	COM Interoperability
12.1.	COM Basics
12.2.	Using COM Components in C#
12.3.	Exposing C# to COM
12.4.	RCW and CCW
13.	Memory Management
13.1.	Garbage Collection Patterns
13.1.1.	Generational GC
13.1.2.	GC.Collect() Usage
13.1.3.	Large Object Heap
13.2.	IDisposable Pattern
13.3.	Finalizers
13.4.	Weak References
13.5.	ref struct and Stack Allocation – High-performance scenarios.
13.6.	Memory Pools (ArrayPool<T>, MemoryPool<T>) – Reducing GC pressure.
14.	Random Number Generation
14.1.	System.Random
14.2.	Cryptographic Random (RNGCryptoServiceProvider)
14.3.	Thread-safe Random
14.4.	Random.Shared (C# 10+) – Thread-safe singleton.
15.	DLL Interoperability
15.1.	Using C# DLLs in Other C# Projects
15.2.	Calling C# from C++/CLI
15.3.	P/Invoke for Native DLLs
16.	Language Features (Modern C#)
16.1.	Nullable Reference Types
16.2.	Pattern Matching Enhancements
16.3.	Records
16.4.	Tuples and Deconstruction
16.5.	Local Functions
16.6.	Target-Typed new Expressions
16.7.	Top-Level Statements
16.8.	Interpolated Strings
16.9.	Default Interface Methods
16.10.	Required Members (C# 11+)
16.11.	Global Using Directives (C# 10+) – Reducing boilerplate.
16.12.	File-Scoped Namespaces (C# 10+) – Cleaner namespace declarations.
17.	C# 11/12/13+ New Features (as applicable)
17.1.	List Patterns
17.2.	Raw String Literals
17.3.	File-scoped Types
17.4.	Primary Constructors
17.5.	Lambda Improvements
17.6.	Checked User-defined Operators
17.7.	Generic Math (Static Abstract Interfaces in C# 11+) – Numerics improvements.
17.8.	UTF-8 String Literals (C# 11+) – Performance optimizations.
18.	Security and Best Practices
18.1.	Secure Coding Guidelines
18.2.	Input Validation and Sanitization
18.3.	Encryption and Hashing (AES, SHA256, etc.)
18.4.	Authentication with Identity
18.5.	Authorization (Roles & Policies)
18.6.	Secure AppSettings Management
18.7.	Secure String Handling (SecureString alternatives) – Best practices.
18.8.	Dependency Injection Security – Avoiding service misuse.
18.9.	Code Analysis & Roslyn Analyzers – Enforcing best practices.
